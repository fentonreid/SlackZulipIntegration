import json
import re
import ply.lex as lex
from flask_login import current_user
from integration.markdown.emojis.shortCodeDict import zulipToSlackDict
from integration.utilities import parseZulipRC


def slackMarkdown(message):
    """
    Converts from slack specific markdown to Zulip markdown.

    :param message: Message from Zulip event
    :type message: String
    """

    boldCount, italicCount, strikeCount, biCount, multiBlockCount = 0, 0, 0, 0, 0
    parsedList = []

    tokens = [
        'EMOJI',
        'NEWLINE',
        'DOUBLELINE',
        'SPACE',
        'SINGLELINEBLOCK', 'MULTILINEBLOCK',
        'BULLETLIST', 'NUMBERLIST',
        'BOLD',
        'ITALIC',
        'STRIKE',
        'LINK',
        'STRING',
        'QUOTE',
        'BOLDITALIC'
    ]

    # token definitions using regular expressions
    t_EMOJI = r":[a-zA-Z\_\-]+:"
    t_NEWLINE = r"\n"
    t_DOUBLELINE = r"\n{2}"
    t_SINGLELINEBLOCK = r"(^\s{0,3}\`{3}.*\`{3}$|^\s{0,3}\~{3}.*\~{3}$|^\s{0,3}\`{1}[^`]*\`{1}$|^[ ]{4,}.*$)"
    t_MULTILINEBLOCK = r"(^\s{0,3}\`{3}[^`\n]*$|^\s{0,3}\~{3}[^~`\n]*$)"
    t_BULLETLIST = r"^[ ]*[\-\+\*][ ].+$"
    t_NUMBERLIST = r"^[ ]{0,3}[1][.][ ].+$"
    t_SPACE = r"[\t ]"
    t_BOLDITALIC = r"\*{3}"
    t_BOLD = r"\*{2}"
    t_ITALIC = r"\*"
    t_STRIKE = r"\~{2}"
    t_LINK = r"\[[^\[\]\(\)]+]\([^\[\]\(\)]+\)"
    t_QUOTE = r"^\s{0,3}\>+"
    t_STRING = r"."

    def t_error(t):
        pass

    lexer = lex.lex(reflags=re.MULTILINE)

    # The Zulip message as input
    lexer.input(message)
    linkList = []


    # go through each token and add to the final string
    def parseToken(currentToken):
        """
        Returns a string based on the token type

        :param currentToken: Token object generated by the lexer
        :type currentToken: Token object
        """
        # get the type and value of the current token
        Ttype = currentToken['type']
        value = currentToken['value']

        # perform a certain action depending on the type of token
        if Ttype == 'BOLD':
            return "*"
        elif Ttype == "EMOJI":
            if current_user.emojiAdditions == "{}":
                return zulipToSlackDict().get(value, '')
            else:
                updateDict = zulipToSlackDict()
                updateDict.update({value: key for key, value in json.loads(current_user.emojiAdditions).items()})
                return updateDict.get(value, '')
        elif Ttype == 'ITALIC':
            return "_"
        elif Ttype == 'STRIKE':
            return "~"
        elif Ttype == 'SPACE':
            return value
        elif Ttype == 'NEWLINE':
            return value
        elif Ttype == 'DOUBLELINE':
            return value
        elif Ttype == 'STRING':
            return value
        elif Ttype == 'LINK':
            filename = value[1:value.find("]")]
            fileurl = value[value.find("]") + 2:-1]

            # if the link isn't a user_upload
            if not fileurl.startswith("/user_uploads"):
                # return the url
                return "<" + fileurl + "|" + slackMarkdown(filename)[0] + ">"

            # otherwise add the user upload to the linkList
            linkList.append((filename, parseZulipRC(current_user.zulipBotRC)['site'] + fileurl))

        elif Ttype == 'MULTILINEBLOCK':
            return '```'

        elif Ttype == 'BULLETLIST':
            # remove all spaces and collect only the text in the list
            splitValue = slackMarkdown(' '.join(value.strip().split()[1:]))[0]
            return '- ' + splitValue

        elif Ttype == 'NUMBERLIST':
            # apply markdown conversion to the values after the numbers
            return str(value.split()[0]) + ' ' + slackMarkdown(' '.join(value.strip().split()[1:]))[0]

        elif Ttype == 'QUOTE':
            if value.find('>') != -1:
                return ">" + value[value.find('>') + 1:]
            return ">" + value

        elif Ttype == 'SINGLELINEBLOCK':
            # ```testing``` = `testing` or ~~~testing~~~ = 'testing'
            if value[:2] in ['``', '~~']:
                return '`' + value[3:-3] + '`'

            # if the first 4 characters are spaces then
            elif value[:4] == ' ' * 4:
                return '`' + value[4:] + '`'

            return value

        elif Ttype == 'BOLDITALIC':
            if parsedList.count("*_") % 2 == 1:
                return "_*"
            return "*_"

        return ""

    tokenList = []

    while True:
        tok = lexer.token()
        # end while loop
        if not tok:
            break

        # converts tok object into a simple dictionary, with key as the type and value as the value e.g. {'STRING', 'this is a string token'}
        tok = {'type': tok.__dict__['type'], 'value': tok.__dict__['value']}

        # count the number of occurrences of bold, italic and strike
        if tok['type'] == 'BOLD':
            boldCount += 1
        elif tok['type'] == 'ITALIC':
            italicCount += 1
        elif tok['type'] == 'STRIKE':
            strikeCount += 1
        elif tok['type'] == 'BOLDITALIC':
            biCount += 1
        elif tok['type'] == 'MULTILINEBLOCK':
            multiBlockCount += 1

        tokenList.append(tok)


    def santiseBoldItalicStrike(tokenType):
        '''
        Prevent bold, italic and strike tokens spanning multiple lines without being ended,
        e.g. """*bold\n*""" -> """*bold\n*"""

        :param tokenType: Name of token that requires sanitisation
        :type tokenType: String
        '''
        for _ in tokenList:
            sanitiseList = []
            for i, token in enumerate(tokenList):
                if token['type'] == tokenType: sanitiseList.append(i)
                if (token['type'] == 'NEWLINE' or i == len(tokenList)-1) and (len(sanitiseList) % 2 == 1 and len(sanitiseList) > 0): tokenList[sanitiseList[-1]]['type'] = 'STRING'


    # remove multiline tokens as these aren't allowed in Slack or Zulip
    [santiseBoldItalicStrike(tokType) for tokType in ['BOLD', 'ITALIC', 'STRIKE', 'BOLDITALIC']]

    # Implementation of ```quote to Slack Quotes
    for counter, tok in enumerate(tokenList):
        if tok['type'] == 'MULTILINEBLOCK':
            splitValue = tok['value'].split()

            if len(splitValue) == 1: splitValue.append(' ')
            if splitValue[0] in ['```quote', '~~~quote'] or splitValue[1] == 'quote':
                tok['type'] = 'STRING'
                tok['value'] = ''
                occuredAt = counter

                for count, blockTok in enumerate(tokenList):
                    if count > occuredAt:
                        if blockTok['type'] == 'MULTILINEBLOCK':
                            blockTok['type'] = 'STRING'
                            blockTok['value'] = ''
                            break

                        # if the token is a newline and the next token is not a multiline block then add quote token
                        elif blockTok['type'] == 'NEWLINE' and count + 1 < len(tokenList) and tokenList[count + 1]['type'] != "MULTILINEBLOCK":
                            tokenList.insert(count + 1, {'type': 'STRING', 'value': '>'})
    

    # Modify quotes to add after each line a quote e.g. >4\n3\n2\n\n1 to >4\n>3\n>2\n\n1
    for tok in tokenList:
        if tok['type'] == 'QUOTE':
            for count, quoteTok in enumerate(tokenList):
                if quoteTok['type'] == 'DOUBLELINE': break
                elif quoteTok['type'] == 'NEWLINE' and count + 1 < len(tokenList) and tokenList[count + 1]['type'] != "QUOTE":
                    tokenList.insert(count + 1, {'type': 'QUOTE', 'value': '>'})


    # For numbered quotes change to incremental values
    for tok in tokenList:
        if tok['type'] == 'NUMBERLIST':
            lineCounter = 2

            for count, numListTok in enumerate(tokenList):
                if numListTok['type'] == 'DOUBLELINE': break
                elif numListTok['type'] == 'NEWLINE' and count + 1 < len(tokenList):
                    tokenList[count + 1] = {'type': 'NUMBERLIST', 'value': str(lineCounter) + '. ' + ' '.join(tokenList[count + 1]['value'].split()[1:])}
                    lineCounter += 1


    # For bullet lists e.g. - a\n- b\n    - c to - a\n- b\n- c
    for tok in tokenList:
        if tok['type'] == 'BULLETLIST':
            for count, numListTok in enumerate(tokenList):
                if numListTok['type'] == 'DOUBLELINE': break
                if numListTok['type'] == 'NEWLINE' and count + 1 < len(tokenList) and tokenList[count + 1]['type'] == 'SINGLELINEBLOCK':
                    tokenList[count + 1]['type'] = 'BULLETLIST'


    # Force new line to the beginning of the message
    if len(tokenList) > 1 and tokenList[0]['type'] in ['QUOTE', 'MULTILINEQUOTE', 'NUMBERLIST', 'BULLETLIST']:
        tokenList.insert(0, {'type': 'NEWLINE', 'value': '\n'})

    for tok in tokenList:
        parsedList.append(parseToken(tok))

    # return a tuple with a Slack formatted message and a list of files
    return ''.join(parsedList), linkList